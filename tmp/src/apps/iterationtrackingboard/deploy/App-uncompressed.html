<!DOCTYPE html>
<html>
<head>
    <title>Iteration Tracking Board</title>

    <script type="text/javascript" src="/apps/x/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.iterationtrackingboard.Column', {
        extend: 'Rally.ui.cardboard.Column',
        alias: 'widget.iterationtrackingboardcolumn',

        getStoreFilter: function(model) {
            var filters = [];
            Ext.Array.push(filters, this.callParent(arguments));
            if (model.elementName === 'HierarchicalRequirement' && this.context.getSubscription().StoryHierarchyEnabled) {
                filters.push({
                    property: 'DirectChildrenCount',
                    value: 0
                });
            }

            return filters;
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.iterationtrackingboard.IterationTrackingTreeView', {
        extend: 'Rally.ui.grid.TreeView',
        alias: 'widget.rallyiterationtrackingtreeview',

        /**
         * Sizes the passed header to fit the max content width.
         * @param {Ext.grid.column.Column/Number} header The header (or index of header) to auto size.
         * @param {Boolean} allowWrapping Should allow content to wrap when finding width.  Defaults to true.
         */
        autoSizeColumn: function(header, allowWrapping, allowShrinking) {
            allowWrapping = allowWrapping !== false;
            allowShrinking = allowShrinking !== false;

            if (Ext.isNumber(header)) {
                header = this.getGridColumns()[header];
            }

            if (header) {
                if (header.isGroupHeader) {
                    header.autoSize();
                    return;
                }
                delete header.flex;

                var newWidth = this.getContentWidth(header, allowWrapping);
                if (!allowShrinking) {
                    newWidth = Math.max(header.getWidth(), newWidth);
                }

                header.setWidth(newWidth);
            }
        },

        /**
         * Returns the max contentWidth of the header's text and all cells in the grid under this header.
         * @param {Ext.grid.column.Column} header The header for which to calculate content width
         * @param {Boolean} allowWrapping Should allow content to wrap when finding width.  Defaults to true.
         */
        getContentWidth: function(header, allowWrapping) {
            allowWrapping = allowWrapping !== false;

            var me = this,
                cells = me.el.query(header.getCellInnerSelector()),
                originalWidth = header.getWidth(),
                i = 0,
                ln = cells.length,
                columnSizer = me.body.select(me.getColumnSizerSelector(header)),
                max = Math.max,
                widthAdjust = 4,
                minAllowedWidth = 40,
                maxWidth;

            if (ln > 0) {
                if (Ext.supports.ScrollWidthInlinePaddingBug) {
                    widthAdjust += me.getCellPaddingAfter(cells[0]);
                }
                if (me.columnLines) {
                    widthAdjust += Ext.fly(cells[0].parentNode).getBorderWidth('lr');
                }
                if (Ext.isGecko || (Ext.isWindows && Ext.isSafari)) {
                    widthAdjust += 4;
                }
            }

            // Set column width to 1px so we can detect the content width by measuring scrollWidth
            columnSizer.setWidth(1);

            // We are about to measure the offsetWidth of the textEl to determine how much
            // space the text occupies, but it will not report the correct width if the titleEl
            // has text-overflow:ellipsis.  Set text-overflow to 'clip' before proceeding to
            // ensure we get the correct measurement.
            header.titleEl.setStyle('text-overflow', 'clip');

            // Allow for padding round text of header
            maxWidth = header.textEl.dom.offsetWidth + header.titleEl.getPadding('lr');

            // revert to using text-overflow defined by the stylesheet
            header.titleEl.setStyle('text-overflow', '');

            var cell, cellEl;
            for (; i < ln; i++) {

                cell = cells[i];
                cellEl = Ext.fly(cell);

                if (!allowWrapping) {
                    cellEl.setStyle('text-overflow', 'clip');
                    cellEl.setStyle('white-space', 'nowrap');
                    cellEl.setStyle('height', '20px');
                }

                maxWidth = max(maxWidth, cell.scrollWidth);

                if (!allowWrapping) {
                    cellEl.setStyle('height', '');
                    cellEl.setStyle('white-space', '');
                    cellEl.setStyle('text-overflow', '');
                }
            }

            // in some browsers, the "after" padding is not accounted for in the scrollWidth
            maxWidth += widthAdjust;

            maxWidth = max(maxWidth, minAllowedWidth);

            // Set column width back to original width
            columnSizer.setWidth(originalWidth);

            return maxWidth;
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     *
     */
    Ext.define('Rally.apps.iterationtrackingboard.IterationTrackingTreeGrid', {
        extend: 'Rally.ui.grid.TreeGrid',
        alias: 'widget.rallyiterationtrackingtreegrid',

        requires: [
            'Rally.apps.iterationtrackingboard.IterationTrackingTreeView',
            'Rally.ui.renderer.RendererFactory'
        ],

        config: {
            viewConfig: {
                xtype: 'rallyiterationtrackingtreeview'
            },

            /**
             * @cfg {String}
             * @inheritdoc
             */
            treeColumnDataIndex: 'FormattedID',

            /**
             * @cfg {String}
             * @inheritdoc
             */
            treeColumnHeader: 'ID',

            /**
             * @cfg {boolean}
             * @inheritdoc
             */
            treeColumnResizable: false,

            /**
             * @cfg {Array}
             * Array of configurations for summary e.g. {field: 'PlanEstimate', type: 'sum', units: 'pt'}
             */
            summaryColumns: [
                {
                    field: 'PlanEstimate',
                    type: 'sum',
                    units: 'pt'
                },
                {
                    field: 'TaskEstimateTotal',
                    type: 'sum',
                    units: 'hr'
                },
                {
                    field: 'TaskRemainingTotal',
                    type: 'sum',
                    units: 'hr'
                }
            ],

            treeColumnRenderer: function (value, metaData, record, rowIdx, colIdx, store) {
                store = store.treeStore || store;
                return Rally.ui.renderer.RendererFactory.getRenderTemplate(store.model.getField('FormattedID')).apply(record.data);
            }
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Abstract class to handle expanding / collapsing for banner widgets
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.BannerWidget', {
        extend: 'Ext.Component',
        alias: 'widget.bannerwidget',

        config: {
            expanded: true
        },

        cls: 'stat-panel',

        data: {},

        tpl: [
            '<div class="expanded-widget"></div>',
            '<div class="collapsed-widget"></div>'
        ],

        onRender: function() {
            if (this.expanded) {
                this.removeCls('collapsed');
            } else {
                this.addCls('collapsed');
            }
            this.callParent(arguments);
        },

        expand: function() {
            this.removeCls('collapsed');
            this.setExpanded(true);
        },

        collapse: function() {
            this.addCls('collapsed');
            this.setExpanded(false);
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * gauge chart for stats banner
     * abstract class
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Gauge', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannergauge',

        requires: [
            'Rally.ui.chart.Chart',
            'Rally.util.Timebox',
            'Rally.util.Colors'
        ],

        config: {
            context: null,
            store: null
        },

        onDataChanged: Ext.emptyFn,
        getChartEl: Ext.emptyFn,
        _getChartConfig: Ext.emptyFn,

        _tzOffsetPromises: {},

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        expand: function() {
            this.callParent();
            if (this.chart) {
                this.chart.doLayout();
            } else {
                this._addChart(this._getChartConfig({}));
            }
        },

        onRender: function() {
            this.callParent(arguments);
            if (!this.getContext().getTimeboxScope().getRecord()) {
                this._addEmptyChart();
            }
        },

        _addEmptyChart: function() {
            this._cleanupChart();
            this._addChart({
                chartData: {
                    series: [{
                        data: [
                            {
                                name: '',
                                y: 100,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            });
        },

        _cleanupChart: function () {
            if (this.chart) {
                this.chart.destroy();
                delete this.chart;
            }
        },

        onDestroy: function () {
            this._cleanupChart();
            this.callParent(arguments);
        },

        onResize: function() {
            if (this.chart && !this.getEl().up('.stats-banner.collapsed')) {
                this.chart.updateLayout();
            }
            this.callParent(arguments);
        },

        refreshChart: function(chartConfig) {
            Ext.suspendLayouts();
            this._cleanupChart();
            if (this.rendered && this.expanded) {
                this._addChart(chartConfig);
            }
            Ext.resumeLayouts();
            this.fireEvent('ready', this);
        },

        _addChart: function(chartConfig) {
            var height = 62;
            this.chart = Ext.create('Rally.ui.chart.Chart', Ext.apply({
                loadMask: false,
                renderTo: this.getChartEl(),
                cls: 'gauge',
                chartConfig: {
                    chart: {
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        defaultSeriesType: 'pie',
                        height: height,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0
                    },
                    plotOptions: {
                        pie: {
                            borderWidth: 0,
                            center: ['50%', '50%'],
                            dataLabels: {
                                enabled: false
                            },
                            size: height - 4,
                            innerSize: height - 14,
                            enableMouseTracking: false, //turns off chart hover, but for tooltips you'll need this on
                            shadow: false
                        }
                    },
                    title: '',
                    tooltip: {
                        enabled: false
                    }
                }
            }, chartConfig));
        },

        getTimeboxData: function() {
            return this._getTZOffset().then({
                success: function (tzOffset) {
                    var timebox = this.getContext().getTimeboxScope().getRecord();
                    if(timebox) {
                        return Rally.util.Timebox.getCounts(
                            timebox.get('StartDate'),
                            timebox.get('EndDate'),
                            this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays,
                            tzOffset);
                    } else {
                        return {
                            remaining: 0,
                            workdays: 0
                        };
                    }
                },
                scope: this
            });
        },

        _getTZOffset: function() {
            var projectRef = Rally.util.Ref.getRelativeUri(this.getContext().getProject());
            if (!Ext.isDefined(this._tzOffsetPromises[projectRef])) {
                var deferred = this._tzOffsetPromises[projectRef] = Ext.create('Deft.Deferred');
                Rally.environment.getIoProvider().httpGet({
                    url: Rally.environment.getServer().getWsapiUrl() + '/iteration',
                    params: {
                        includeSchema: true,
                        pagesize:1,
                        fetch: false,
                        project: projectRef
                    },
                    success: function(results) {
                        deferred.resolve((results.Schema.properties.EndDate.format.tzOffset || 0) / 60);
                    },
                    requester: this,
                    scope: this
                });
            }
            return this._tzOffsetPromises[projectRef];
        },

        getAcceptanceData: function () {
            return this._getScheduleStates().then({
                success: function (scheduleStates) {
                    var acceptanceData = {
                        accepted: 0,
                        total: 0
                    };
                    var accepted = _.indexOf(scheduleStates, 'Accepted');
                    _.each(this.store.getRange(), function (record) {
                        var estimate = record.get('PlanEstimate') || 0;
                        if (_.indexOf(scheduleStates, record.get('ScheduleState')) >= accepted) {
                            acceptanceData.accepted += estimate;
                        }
                        acceptanceData.total += estimate;
                    }, this);
                    return acceptanceData;
                },
                scope: this,
                requester: this
            });
        },

        _getScheduleStates: function () {
            if (this._scheduleStates) {
                return Deft.Promise.when(this._scheduleStates);
            } else {
                return this.store.model.getField('ScheduleState').getAllowedValueStore().load().then({
                    success: function (records) {
                        this._scheduleStates = _.map(records, function (record) {
                            return record.get('StringValue');
                        });
                        return this._scheduleStates;
                    },
                    scope: this,
                    requester: this
                });
            }
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows planned velocity for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.PlannedVelocity', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbannerplannedvelocity',
        require: ['Rally.util.Colors'],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Planned Velocity</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text percent-offset">',
            '{percentage}<div class="metric-percent">%</div>',
            '</div>',
            '<div class="metric-subtext">{estimate} of {plannedVelocity} {unit}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">Planned Velocity</div>',
            '<div class="stat-metric">{percentage}<span class="metric-percent">%</span></div>',
            '</div>'
        ],

        config: {
            data: {
                percentage: 0,
                estimate: 0,
                plannedVelocity: 0,
                unit: ''
            }
        },

        onDataChanged: function() {
            this._getRenderData().then({
                success: function(renderData){
                    this.update(renderData);
                    this.refreshChart(this._getChartConfig(renderData));
                },
                scope: this
            });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },

        _getTimeboxUnits: function() {
            return this.getContext().getTimeboxScope().getType() === 'iteration' ?
                this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName :
                this.getContext().getWorkspace().WorkspaceConfiguration.ReleaseEstimateUnitName;
        },

        _getRenderData: function() {
            var deferred = Ext.create('Deft.Deferred');
            var estimate = _.reduce(this.store.getRange(), function(accum, record) {
                return accum + record.get('PlanEstimate') || 0;
            }, 0);

            estimate = Math.round(estimate * 100) / 100;

            var timebox = this.getContext().getTimeboxScope();
            var timeboxUnits = this._getTimeboxUnits();
            timebox.getPlannedVelocity().then({
                success: function(plannedVelocity){
                    var percentage = plannedVelocity === 0 ? 0 : Math.round(estimate / plannedVelocity * 100);

                    var data = {
                        estimate: estimate,
                        percentage: percentage,
                        plannedVelocity: plannedVelocity,
                        unit: timeboxUnits
                    };
                    deferred.resolve(data);
                }
            });

            return deferred.promise;
        },

        _getChartConfig: function(renderData) {
            var percentage = renderData.percentage,
                percentagePlanned = percentage % 100 || 100,
                color = Rally.util.Colors.cyan_med,
                secondaryColor = Rally.util.Colors.grey1;

            if (percentage > 100) {
                color = Rally.util.Colors.blue;
                secondaryColor = Rally.util.Colors.cyan;
            } else if (percentage > 70) {
                color = Rally.util.Colors.cyan;
            } else if (percentage === 0) {
                color = Rally.util.Colors.grey1;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Planned Estimate Total',
                                y: percentagePlanned,
                                color: color
                            },
                            {
                                name: '',
                                y: 100 - percentagePlanned,
                                color: secondaryColor
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows days remaining for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.TimeboxEnd', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbannertimeboxend',
        requires: [
            'Rally.util.Timebox',
            'Rally.util.Colors'
        ],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">{type} End</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text">',
            '{remaining}',
            '</div>',
            '<div class="metric-subtext">days left of {workdays}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">{type} End</div>',
            '<div class="stat-metric">{remaining}<span class="stat-metric-secondary"> days</span></div>',
            '</div>'
        ],

        config: {
            data: {
                type: 'Iteration',
                remaining: 0,
                workdays: 0
            }
        },

        onDataChanged: function() {
            Deft.Promise.all([
                    this.getAcceptanceData(),
                    this.getTimeboxData()
                ]).then({
                    success: this._onDataAssembled,
                    scope: this
                });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },

        _getRenderData: function() {
            var data = _.merge(
                {type: Ext.String.capitalize(this.getContext().getTimeboxScope().getType())},
                this.acceptanceData,
                this.timeboxData
            );

            return data;
        },

        _onDataAssembled: function (results) {
            this.acceptanceData = results[0];
            this.timeboxData = results[1];

            var renderData = this._getRenderData();
            this.update(renderData);

            this.refreshChart(this._getChartConfig(renderData));
        },

        _getChartConfig: function (renderData) {
            var decimal = renderData.remaining / renderData.workdays,
                percentLeft = decimal < 1 ? Math.round(decimal * 100) : 0,
                color = Rally.util.Colors.cyan;

            if (renderData.total === 0) {
                color = Rally.util.Colors.grey1;
            } else if (percentLeft === 0) {
                color = renderData.accepted === renderData.total ? Rally.util.Colors.lime : Rally.util.Colors.blue;
            } else if (percentLeft <= 25) {
                color = Rally.util.Colors.blue;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Days Done',
                                y: 100 - percentLeft,
                                color: color
                            },
                            {
                                name: 'Days Left',
                                y: percentLeft,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows defects active for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Defects', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannerdefects',
        requires: [],

        config: {
            context: null,
            store: null,
            data: {
                activeCount: 0
            }
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Defects</div>',
            '<div class="stat-metric">',
            '<div class="metric-icon icon-defect"></div>{activeCount}',
            '<div class="stat-secondary">Active</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-defect"></span>',
            '<div class="stat-title">Defects</div>',
            '<div class="stat-metric">{activeCount}</div>',
            '</div>'
        ],

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        onDataChanged: function() {
            this.update(this._getRenderData());
            this.fireEvent('ready', this);
        },

        _getActiveDefectCount: function() {
            var activeDefects = 0;
            _.each(this.store.getRange(), function(record){
                var defectSummary = record.get('Summary') && record.get('Summary').Defects;
                if (defectSummary) {
                    _.each(defectSummary.State, function(count, state) {
                        if (state !== 'Closed') {
                            activeDefects += count;
                        }
                    }, this);
                } else if(record.self.typePath === 'defect' && record.get('State') !== 'Closed') {
                    activeDefects++;
                }
            }, this);
            return activeDefects;
        },

        _getRenderData: function() {
            return {activeCount: this._getActiveDefectCount()};
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows accepted work units for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Accepted', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.Gauge',
        alias:'widget.statsbanneraccepted',
        requires: ['Rally.util.Colors'],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Accepted</div>',
            '<div class="stat-metric">',
            '<div class="metric-chart"></div>',
            '<div class="metric-chart-text percent-offset">',
            '{percentage}<div class="metric-percent">%</div>',
            '</div>',
            '<div class="metric-subtext">{accepted} of {total} {unit}</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="stat-title">Accepted</div>',
            '<div class="stat-metric">{percentage}<span class="metric-percent">%</span></div>',
            '</div>'
        ],

        config: {
            data: {
                percentage: 0,
                accepted: 0,
                total: 0,
                unit: ''
            }
        },

        onDataChanged: function () {
            Deft.Promise.all([
                    this.getAcceptanceData(),
                    this.getTimeboxData()
                ]).then({
                    success: this._onDataAssembled,
                    scope: this
                });
        },

        getChartEl: function() {
            return this.getEl().down('.metric-chart');
        },

        _getTimeboxUnits: function() {
            return this.getContext().getTimeboxScope().getType() === 'iteration' ?
                    this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName :
                    this.getContext().getWorkspace().WorkspaceConfiguration.ReleaseEstimateUnitName;
        },

        _getRenderData: function() {
            var data = _.merge(
                {unit: this._getTimeboxUnits()},
                this.acceptanceData,
                this.timeboxData
            );

            data.accepted = Ext.util.Format.round(data.accepted, 2);
            data.total = Ext.util.Format.round(data.total, 2);
            data.percentage = Math.round((data.accepted / data.total) * 100) || 0;

            return data;
        },

        _onDataAssembled: function (results) {
            this.acceptanceData = results[0];
            this.timeboxData = results[1];

            var renderData = this._getRenderData();
            this.update(renderData);

            this.refreshChart(this._getChartConfig(renderData));
        },

        _getChartConfig: function(renderData) {
            var color = Rally.util.Colors.cyan,
                daysRemaining = renderData.remaining / renderData.workdays,
                percentage = renderData.percentage;

            if (percentage === 100) {
                color = Rally.util.Colors.lime;
            } else if (daysRemaining === 0) {
                color = Rally.util.Colors.blue;
            }

            return {
                chartData: {
                    series: [{
                        data: [
                            {
                                name: 'Accepted',
                                y: percentage,
                                color: color
                            },
                            {
                                name: '',
                                y: 100 - percentage,
                                color: Rally.util.Colors.grey1
                            }
                        ]
                    }]
                }
            };
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows completed tasks for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.Tasks', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannertasks',
        requires: [],

        config: {
            context: null,
            store: null,
            data: {
                count: 0
            }
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title">Tasks</div>',
            '<div class="stat-metric">',
            '<span class="metric-icon icon-task"></span>{count}',
            '<div class="stat-secondary">Active</div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-task"></span>',
            '<div class="stat-title">Tasks</div>',
            '<div class="stat-metric">{count}</div>',
            '</div>'
        ],

        initComponent: function() {
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
        },

        onDataChanged: function() {
            this.update(this._getRenderData());
            this.fireEvent('ready', this);
        },

        _getRenderData: function() {
            return {count: this._getTaskCount()};
        },

        _getTaskCount: function() {
            var taskCount = 0;
            _.each(this.store.getRange(), function(record){
                var taskSummary = record.get('Summary') && record.get('Summary').Tasks;
                if (taskSummary) {
                    _.each(taskSummary['state+blocked'], function(count, state) {
                        if (!Ext.String.startsWith(state, 'Completed')) {
                            taskCount += count;
                        }
                    }, this);
                }
            }, this);
            return taskCount;
        }
    });
})();
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        _configureYAxis: function(ticks, axis) {

            var intervalY = (this.chartComponentConfig.chartConfig.yAxis[axis].max - 0) / (ticks - 1);
            var ticksY = [];
            for (var i = 0; i < ticks; i++) {
                ticksY.push(i * intervalY);
            }
            this.chartComponentConfig.chartConfig.yAxis[axis].tickPositions = ticksY;
        },

        _configureYAxisIntervals: function () {
            var ticks = 5; // not much chart space, limit to 5
            this._configureYAxis(ticks, 0);
            if(this.chartType === "burndown") { // cumulative flow only has y axis 0
                this._configureYAxis(ticks, 1);
            }
        },

        _getElementValue: function (element) {
            if (element.textContent !== undefined) {
                return element.textContent;
            }
            return element.text;
        },
        
        _getStringValues: function (elements) {
            var i;
            var strings = [];
            for (i = 0; i < elements.length; i++) {
                strings.push(this._getElementValue(elements[i]));
            }
            return strings;
        },

        _getNumberValues: function (elements) {
            var i;
            var numbers = [];
            for (i = 0; i < elements.length; i++) {
                if(this._getElementValue(elements[i])) {
                    numbers.push(this._getElementValue(elements[i]).split(' ')[0] * 1);
                } else {
                    numbers.push(0);
                }

            }
            return numbers;
        },

        _computeMaxYAxisValue: function(series) {
            var i, j, max = 0.0;
            // sum each day's values and find the largest sum
            for(i=0; i < series[0].data.length; i++) {
                var val = 0.0;
                for(j=0; j < series.length; j++) {
                    // if is for insurance, _should_ always be true
                    if(series[j].data.length === series[0].data.length) {
                        val += series[j].data[i];
                    }
                }
                if(val > max) {
                    max = val;
                }
            }
            max = Math.ceil(max / 4) * 4;  // round up to multiple of 4 so we will create 5 integral tick marks

            return (max === 0) ? 4 : max;
        },

        _createChartDatafromXML: function (xml) {
            var parseXml;

            if (typeof window.DOMParser !== "undefined") {
                parseXml = function (xmlStr) {
                    return ( new window.DOMParser() ).parseFromString(xmlStr, "text/xml");
                };
            } else if (typeof window.ActiveXObject !== "undefined" &&
                new window.ActiveXObject("Microsoft.XMLDOM")) {
                parseXml = function (xmlStr) {
                    var xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = "false";
                    xmlDoc.loadXML(xmlStr);
                    return xmlDoc;
                };
            } else {
                throw new Error("No XML parser found");
            }

            return parseXml(xml);
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart", {
            requires: [
                "Rally.ui.chart.Chart"
            ],

            chartComponentConfig: {
               xtype: "rallychart",
               suppressClientMetrics: true /* keeps rallychart::lookback query time from displaying in client metrics */
            }
        });
}());

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart", {
        alias: "widget.statsbannerburndownchart",
        extend: "Ext.Container",
        requires: [
            'Rally.ui.chart.Chart'
        ],
        mixins: [
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin",
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart"
        ],

        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Burndown',
        minimalMode: false,
        onChartDataLoaded: Ext.emptyFn,

        initComponent: function() {
            this.callParent(arguments);

            Ext.Ajax.request({
                url: '/slm/charts/itsc.sp',
                params: {
                    iterationOid: this.context.getTimeboxScope().getRecord().getId(),
                    cpoid: this.context.getProject().ObjectID
                },
                method: 'GET',
                withCredentials: true,
                success: function(response, request) {
                    this._loadData(response.responseText);
                },
                requester: this,
                scope: this
            });
        },

        _loadData: function(chartData) {
            var xmlDoc = this._createChartDatafromXML(chartData);
            this._createBurndownChartDatafromXML(xmlDoc);
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;

            return Ext.Object.merge({
                xtype: 'rallychart',
                chartColors: ["#005eb8", "#666666", "#8dc63f" ],
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartConfig: {
                    chart: {
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        zoomType: 'xy',
                        alignTicks: false,
                        animation: true,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            shadow: false,
                            borderWidth: 0,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            },
                            events: {
                                click: clickChartHandler
                            }
                        },
                        column: {
                            events: {
                                click: clickChartHandler
                            }
                        }
                    },
                    legend: { enabled: true },
                    title: { text: null },
                    xAxis: {
                        tickmarkPlacement: 'on',
                        tickInterval: 1
                    },
                    yAxis: [
                        {
                            title: { text: null },
                            min: 0,
                            labels: { style: { color: "#005eb8" } }
                        },
                        {
                            title: { text: null },
                            min: 0,
                            opposite: true,
                            labels: { style: { color: "#8dc63f" } }
                        }
                    ]
                },
                chartData: {
                    categories: [],
                    series: [
                        {
                            name: "To Do",
                            type: "column",
                            data: [],
                            tooltip: { enabled: false }
                        },
                        {
                            name: "Ideal",
                            type: "line",
                            dashStyle: "Solid",
                            data: [],
                            marker : {
                               enabled : true,
                               radius : 3
                            },
                            tooltip: { enabled: false }
                        },
                        {
                            name: "Accepted",
                            type: "column",
                            data: [],
                            yAxis: 1,
                            tooltip: { enabled: false }
                        }
                    ]
               }
           }, overrides || {});
        },

        _createMinimalConfig: function(){
            var config = this._createChartConfig();
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;
            delete config.chartData.series[1].marker;

            config = Ext.Object.merge(config, {
                chartConfig: {
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },
                    yAxis: [
                        {
                            title: { text: null },
                            min: 0,
                            labels: { enabled: false }
                        },
                        {
                            title: { text: null },
                            min: 0,
                            opposite: true,
                            labels: { enabled: false }
                        }
                    ],
                    title: { text: null }
                }
            });
            return config;
        },

        _createBurndownChartDatafromXML: function (xmlDoc) {

            this.chartComponentConfig = this.minimalMode ? this._createMinimalConfig() : this._createChartConfig();

            var xmlChartData = xmlDoc.getElementsByTagName("chart_data")[0];
            var xmlChartValueText = xmlDoc.getElementsByTagName("chart_value_text")[0];
            var draw = xmlDoc.getElementsByTagName("draw")[0];
            var axis_value = xmlDoc.getElementsByTagName("axis_value")[1];

            var rows = xmlChartData.getElementsByTagName("row");

            // this makes no sense...The thing labeled Accepted in the <chart_data> element, isn't.
            // The thing that is Accepted, is buried in the <chart_value_text> element

            this.chartComponentConfig.chartData.categories = this._getStringValues(rows[0].getElementsByTagName("string")); // categories
            this.chartComponentConfig.chartData.series[0].data = this._getNumberValues(rows[1].getElementsByTagName("number")); //todo;
            this.chartComponentConfig.chartData.series[1].data = this._getNumberValues(rows[3].getElementsByTagName("number")); //ideal;
            this.chartComponentConfig.chartData.series[2].data = this._getNumberValues(xmlChartValueText.getElementsByTagName("row")[2].getElementsByTagName("number")); //accepted;
            this.chartComponentConfig.chartConfig.yAxis[0].max = axis_value.getAttribute("max") * 1;

            var texts = draw.getElementsByTagName("text");
            // find the last <text element with orientation="vertical_down" attribute, that's the max y-axis 2 setting
            for (i = 0; i < texts.length; i++) {
                if (texts[i].getAttribute("orientation") === "vertical_down") {
                    this.chartComponentConfig.chartConfig.yAxis[1].max = (this._getElementValue(texts[i]) * 1);
                }
            }
            this._configureYAxisIntervals();

            this.chartComponentConfig.chartConfig.xAxis.tickInterval = Math.floor(this.chartComponentConfig.chartData.series[0].data.length / 4);

            this.add(this.chartComponentConfig);
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        }
    });
})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart", {
        alias: "widget.statsbannercumulativeflowchart",
        extend: "Ext.Container",
        requires: [ 'Rally.ui.chart.Chart' ],
        mixins: [
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressMixin",
            "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.IterationProgressChart"
        ],
        cls: 'rally-iteration-progress-cumulative-flow-chart',
        currentScope: undefined,
        context: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Cumulative Flow',
        minimalMode: false,

        initComponent: function() {
            this.callParent(arguments);

            Ext.Ajax.request({
                url: '/slm/charts/icfc.sp',
                params: {
                    iterationOid: this.context.getTimeboxScope().getRecord().getId(),
                    cpoid: this.context.getProject().ObjectID,
                    bigChart: true
                },
                method: 'GET',
                withCredentials: true,
                success: function(response, request) {
                    this._loadData(response.responseText);
                },
                requester: this,
                scope: this
            });
        },

        _loadData: function(chartData) {
            var xmlDoc = this._createChartDatafromXML(chartData);
            this._createCumulativeFlowChartDatafromXML(xmlDoc);
        },

        _createMinimalConfig: function(){
            var config = this._createChartConfig();
            delete config.chartConfig.xAxis;
            delete config.chartConfig.yAxis;

            return Ext.Object.merge(config, {
                chartConfig: {
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    legend: { enabled: false },
                    xAxis: {
                        labels: { enabled: false },
                        tickPositions: []
                    },
                    yAxis: [{
                        title: {
                            text: null
                        },
                        min: 0,
                        labels: { enabled: false }
                    }],
                    title: { text: null }
                }
            });
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;

            return Ext.Object.merge({
                xtype: 'rallychart',
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartColors: [  // RGB values obtained from here: http://ux-blog.rallydev.com/?cat=23
                                "#C0C0C0",  // $grey4
                                "#FF8200",  // $orange
                                "#F6A900",  // $gold
                                "#FAD200",  // $yellow
                                "#CADDA3",  // $lime
                                "#1E7C00"
                            ],
                chartConfig: {
                    chart: {
                        height: this.height,
                        width: this.width,
                        spacingTop: 2,
                        spacingRight: 0,
                        spacingBottom: 8,
                        spacingLeft: 0,
                        alignTicks: false,
                        animation: true,
                        type: "area",
                        events: {
                            click: clickChartHandler
                        }
                    },
                    plotOptions: {
                        series: {
                            animation: true,
                            marker: {
                                enabled: false,
                                states: {
                                    hover: {
                                        enabled: false
                                    }
                                }
                            }
                        },
                        area: {
                            stacking: 'normal',
                            events: {
                                click: clickChartHandler
                            }
                        }
                    },
                    legend: {
                        enabled: true
                    },
                    title: { text: null },
                    xAxis: {
                        tickmarkPlacement: 'on',
                        tickInterval: 1
                    },
                    yAxis: [{
                        title: { text: null },
                        min: 0,
                        labels: {
                            style: { color: "#005eb8" }
                        }
                    }]
                },
                chartData: {
                   categories: [],
                   series: []
                }
           }, overrides || {});
        },

        _createCumulativeFlowChartDatafromXML: function (xmlDoc) {

            this.chartComponentConfig = this.minimalMode ? this._createMinimalConfig() : this._createChartConfig();

            var xmlChartData = xmlDoc.getElementsByTagName("chart_data")[0];

            var rows = xmlChartData.getElementsByTagName("row");
            var i, j;
            this.chartComponentConfig.chartData.categories = this._getStringValues(rows[0].getElementsByTagName("string")); // categories
            for(j=rows.length-1, i = 0 ; j > 0; j--,i++) {
                this.chartComponentConfig.chartData.series[i] = {};
                this.chartComponentConfig.chartData.series[i].data = this._getNumberValues(rows[j].getElementsByTagName("number"));
                this.chartComponentConfig.chartData.series[i].name = this._getStringValues(rows[j].getElementsByTagName("string"))[0];
            }

            // the 'max' y axis value in the xml isn't correct, so we'll calculate it ourselves...
            this.chartComponentConfig.chartConfig.yAxis[0].max = this._computeMaxYAxisValue(this.chartComponentConfig.chartData.series);

            this._configureYAxisIntervals();


            // Use number of ScheduleState values to show as a surrogate for with of the legend text.
            if(this.chartComponentConfig.chartData.series.length === 6) {
                this.chartComponentConfig.chartConfig.legend.itemStyle = { fontSize: '8px'};
            } else if(this.chartComponentConfig.chartData.series.length === 5) {
                this.chartComponentConfig.chartConfig.legend.itemStyle = { fontSize: '10px'};
            } // else it will default to 12px

            this.chartComponentConfig.chartConfig.xAxis.tickInterval = Math.floor(this.chartComponentConfig.chartData.series[0].data.length / 4);

            this.add(this.chartComponentConfig);
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        }
    });

})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart", {
        alias: "widget.statsbannerpiechart",
        extend: "Ext.Container",
        requires: [
            'Rally.ui.chart.Chart'
        ],
        mixins: {
            recordable: 'Rally.clientmetrics.ClientMetricsRecordable'
        },

        currentScope: undefined,
        height: undefined,
        width: undefined,
        displayTitle: 'Pie',
        config: {
            context: null
        },

        initComponent: function() {
            this.callParent(arguments);

            if (this._storyStates === undefined) {
                Rally.data.ModelFactory.getModels({
                    types: ['UserStory', 'Defect', 'DefectSuite', 'TestSet'],
                    context: this.getContext(),
                    scope: this,
                    requester: this,
                    success: function(models){
                        models.UserStory.getField('ScheduleState').getAllowedValueStore().load({
                            callback: this._createStateMap,
                            requester: this,
                            scope: this
                        });
                    }
                });
            } else {
                this._loadArtifacts();
            }
        },

        _createStateMap: function(allowedValues) {
            var stateMap = ['Defined', 'In-Progress', 'Completed'],
                stateMapIndex = 0,
                storyStates = {};

            _.each(allowedValues, function(value) {
                var state = value.data.StringValue;
                if (state) {
                    if (state === stateMap[stateMapIndex + 1]) {
                        stateMapIndex++;
                    }
                    storyStates[state] = stateMap[stateMapIndex];
                }
            });

            this._storyStates = storyStates;
            this._loadArtifacts();
        },

        _loadArtifacts: function() {
            this._chartData = [];
            this._childChartData = [];
            
            this.store = Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['User Story', 'Defect', 'Defect Suite', 'Test Set'],
                fetch: ['Defects', 'PlanEstimate', 'Requirement', 'FormattedID', 'Name', 'Blocked', 'BlockedReason', 'ScheduleState', 'State', 'Tasks', 'TestCases'],
                filters: [this.context.getTimeboxScope().getQueryFilter()],
                context: this.context.getDataContext(),
                limit: Infinity,
                requester: this,
                autoLoad: true,
                listeners: {
                    load: this._loadChildCollections,
                    scope: this
                }
            });
        },

        _loadChildCollections: function() {
            var records = this.store.getRange();
            var promises = [];
            _.each(records, function(record) {
                if (record.get('Defects') && record.get('Defects').Count) {
                    promises.push(record.getCollection('Defects', {
                        fetch: ['FormattedID', 'Name', 'ScheduleState', 'Blocked', 'BlockedReason', 'Requirement', 'State']
                    }).load({
                        requester: this,
                        callback: function(defects) {
                            record.get('Defects').Results = defects;
                        }
                    }));
                }
                if (record.get('Tasks') && record.get('Tasks').Count) {
                    promises.push(record.getCollection('Tasks', {
                        fetch: ['FormattedID', 'Name', 'Blocked', 'BlockedReason', 'WorkProduct', 'State']
                    }).load(
                        {
                            requester: this,
                            callback: function(tasks) {
                                record.get('Tasks').Results = tasks;
                            }
                        }
                    ));
                }
                if (record.get('TestCases') && record.get('TestCases').Count){
                    promises.push(record.getCollection('TestCases', {
                        fetch: ['FormattedID', 'Name', 'Type', 'WorkProduct']
                    }).load({
                        requester: this,
                        callback: function(testCases){
                            record.get('TestCases').Results = testCases;
                            }
                        }
                    ));
                }
            });

            if (promises.length > 0) {
                Deft.Promise.all(promises).then({
                    success: this._onAllDataLoaded,
                    scope: this
                });
            } else {
                this._onAllDataLoaded();
            }
        },

        _onAllDataLoaded: function() {
            _.each(this.store.getRange(), function(record) {
                var defects = record.get('Defects');
                var defectCount = (defects && defects.Count) || 0;
                var tasks = record.get('Tasks');
                var taskCount = (tasks && tasks.Count) || 0;
                var testCases =  record.get('TestCases');
                var testCaseCount = (testCases && testCases.Count) || 0;
                var relatedCount = taskCount + defectCount + testCaseCount;
                var planEstimate = record.get('PlanEstimate') || 1;
                var pointSizeForChildren = (planEstimate / relatedCount) || 1;
                var nullPointString = 'No tasks or defects.';

                this._addPointForTopLevelItem(record, relatedCount);

                if (relatedCount === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                } else {
                    if (defects && defects.Results) {
                        _.each(defects.Results, function(defect) {
                            this._addPointForChildItem(defect, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (tasks && tasks.Results) {
                        _.each(tasks.Results, function(task) {
                            this._addPointForChildItem(task, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (testCases && testCases.Results) {
                        _.each(testCases.Results, function(testCase) {
                            this._addPointForChildItem(testCase, record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                        }, this);
                    }
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

            this.recordLoadEnd();
        },

        _onLoad: function() {
            this.fireEvent('contentupdated', this);
            this.fireEvent('ready', this);
            if (Rally.BrowserTest) {
                Rally.BrowserTest.publishComponentReady(this);
            }
        },

        _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;
            var height = this.height;
            var pieHeight = this.height * 0.9;

            return Ext.Object.merge({
                xtype: 'rallychart',
                loadMask: false,
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartData: {
                    series: [
                        {
                            type: 'pie',
                            name: 'Parents',
                            data: this._chartData,
                            size: pieHeight,
                            allowPointSelect: false,
                            dataLabels: {
                                enabled: false
                            }
                        },
                        {
                            type: 'pie',
                            name: 'Children',
                            data: this._childChartData,
                            size: pieHeight,
                            innerSize: 0.8 * pieHeight,
                            allowPointSelect: false,
                            dataLabels: { enabled: false }
                        }
                    ]
                },

                chartConfig: {
                    chart: {
                        type: 'pie',
                        height: height,
                        width: this.width,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    subtitle: {
                        useHTML: true,
                        text: '<table align="center" class="pie-chart-legend"><tr><td><span class="legend-swatch defined-sample-swatch"></span><span>Defined</td>' +
                              '<td><span class="legend-swatch in-progress-sample-swatch"></span>In-Progress</td>' +
                              '<td><span class="legend-swatch completed-sample-swatch"></span>Completed</td>' +
                              '<td><span class="legend-swatch blocked-sample-swatch"></span>Blocked</td></tr></table>',
                        verticalAlign: 'bottom',
                        floating: true,
                        x: -10,
                        y: -20
                    },
                    tooltip: {
                        formatter: this._formatTooltip
                    },
                    spacingTop: 0,
                    title: { text: null },
                    plotOptions: {
                        pie: {
                            shadow: false,
                            center: ['50%', '45%'],
                            point: {
                                events: {
                                    click: function(event) {
                                        if (this.ref) {
                                            Rally.nav.Manager.showDetail(this.ref);
                                        }
                                    }
                                }
                            },
                            showInLegend: false
                        }
                    }
                }
            }, overrides || {});
        },

        _addPointForTopLevelItem: function(record, relatedCount) {
            var blocked = record.get('Blocked');
            var color = this._colorFromStatus(this._storyStates[record.get('ScheduleState')], blocked);
            var pointSize = record.get('PlanEstimate') || 1;

            this._chartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: record.get('ScheduleState'),
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: relatedCount > 0,
                relatedCount: relatedCount,
                ref: record.get('_ref'),
                parentFormattedID: null
            });
        },

        _colorFromStatus: function(state, blocked) { //refactor into css and classes, should get cleaner
            var progressColors = {
                'Defined': '#C0C0C0', // light gray
                'In-Progress': '#00A9E0', // cyan
                'Completed': '#8DC63F', // lime
                'Blocked': '#EE1C25' // red
            };
            var color =  progressColors[state];
            if (blocked) {
                color = progressColors.Blocked;
            }
            return color;
        },

        _addPointForChildItem: function(record, parentFormattedID, pointSize, parentState, isParentBlocked) {
            var blocked = record.get('Blocked');
            var state = record.get('ScheduleState') || record.get('State') || record.get('Type');
            var color = this._colorFromStatus(this._storyStates[parentState || state], blocked || isParentBlocked);

            this._childChartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: state,
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: false,
                relatedCount: 0,
                ref: record.get('_ref'),
                parentFormattedID: parentFormattedID
            });
        },

        _formatTooltip: function() {
            var relatedCount = '';
            var blockedMessage = '';
            var artifactName = this.point.rallyName ? '<b>' + this.point.name + '</b>: ' + this.point.rallyName + '<br/>' : this.point.name;

            if (this.point.blocked) {
                blockedMessage = '<b>Blocked</b>';
                if (this.point.blockedReason) {
                    blockedMessage += ': ' + this.point.blockedReason;
                }
            }

            if (this.point.series && this.point.series.name === 'Parents') {
                if(!this.point.userStory) {
                    var numRelated = this.point.relatedCount || 0;
                    relatedCount = 'Related Items: ' + numRelated;
                }
                return artifactName + this.point.status + '<br/>' + relatedCount + '<br/>' + blockedMessage;
            } else {
                return artifactName + this.point.status + '<br/>' + blockedMessage;
            }
        }
    });
})();

                (function(){
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.MinimalPieChart", {
        alias: "widget.statsbannerminimalpiechart",
        extend: "Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart",

        _loadArtifacts: function() {
            this._chartData = [];
            this._childChartData = [];
            this._createDataPointsFromSummary();
        },

        _createDataPointsFromSummary: function() {
            _.each(this.store.getRange(), function(record){
                var summary = record.get('Summary');
                var totalChildItems = 0;
                var planEstimate = record.get('PlanEstimate') || 1;
                var nullPointString = 'No tasks or defects.';
                var testCases = record.get('TestCases');
                var keys, state, scheduleState, blocked, count;

                totalChildItems += summary.Defects ? summary.Defects.Count : 0;
                totalChildItems += summary.Tasks ? summary.Tasks.Count : 0;
                totalChildItems += testCases ? testCases.Count : 0;

                var pointSizeForChildren = (planEstimate / totalChildItems) || 1;

                this._addPointForTopLevelItem(record, totalChildItems);

                if (totalChildItems === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                }
                if (summary.Tasks && summary.Tasks.Count){
                    keys = _.keys(summary.Tasks['state+blocked']);
                    _.each(keys, function(key) {
                        state = key.split('+');
                        scheduleState =  state[0];
                        blocked = state[1] === 'true';
                        count = summary.Tasks['state+blocked'][key];
                        _.each(_.range(0, count), function(point) {
                            this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, scheduleState, blocked);
                        }, this);
                    }, this);
                }
                if (summary.Defects && summary.Defects.Count){
                    keys = _.keys(summary.Defects['schedulestate+blocked']);
                    _.each(keys, function(key) {
                        state = key.split('+');
                        scheduleState =  state[0];
                        blocked = state[1] === 'true';
                        count = summary.Defects['schedulestate+blocked'][key];
                        _.each(_.range(0, count), function(point) {
                            this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, scheduleState, blocked);
                        }, this);
                    }, this);
                }
                if (testCases && testCases.Count){
                    _.each(_.range(0,testCases.Count), function(point){
                        this._addPointForChildItem(record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                    }, this);
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

        },

        _onAllDataLoaded: function() {
            _.each(this.store.getRange(), function(record) {
                var defects = record.get('Defects');
                var defectCount = (defects && defects.Count) || 0;
                var tasks = record.get('Tasks');
                var taskCount = (tasks && tasks.Count) || 0;
                var testCases =  record.get('TestCases');
                var testCaseCount = (testCases && testCases.Count) || 0;
                var relatedCount = taskCount + defectCount + testCaseCount;
                var planEstimate = record.get('PlanEstimate') || 1;
                var pointSizeForChildren = (planEstimate / relatedCount) || 1;
                var nullPointString = 'No tasks or defects.';

                this._addPointForTopLevelItem(record, relatedCount);

                if (relatedCount === 0) {
                    this._childChartData.push({
                        name: nullPointString,
                        y: planEstimate,
                        color: '#FFF',
                        rallyName: null,
                        status: '',
                        blocked: false,
                        blockedReason: '',
                        hasChildren: false,
                        relatedCount: 0,
                        ref: null,
                        parentFormattedID: null
                    });
                } else {
                    if (defects && defects.Results) {
                        _.each(defects.Results, function(defect) {
                            this._addPointForChildItem(defect, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (tasks && tasks.Results) {
                        _.each(tasks.Results, function(task) {
                            this._addPointForChildItem(task, record.get('FormattedID'), pointSizeForChildren);
                        }, this);
                    }

                    if (testCases && testCases.Results) {
                        _.each(testCases.Results, function(testCase) {
                            this._addPointForChildItem(testCase, record.get('FormattedID'), pointSizeForChildren, record.get('ScheduleState'), record.get('Blocked'));
                        }, this);
                    }
                }
            }, this);

            var chart = this._createChartConfig();
            this.add(chart);

            this.recordLoadEnd();
        },

         _createChartConfig: function(overrides) {
            var clickChartHandler = _.isFunction(this.clickHandler) ? this.clickHandler : Ext.emptyFn;
            var height = this.height;
            return Ext.Object.merge({
                xtype: 'rallychart',
                loadMask: false,
                updateAfterRender: Ext.bind(this._onLoad, this),

                chartData: {
                    series: [
                        {
                            type:'pie',
                            name: 'Parents',
                            data: this._chartData,
                            size: height,
                            allowPointSelect: false,
                            dataLabels: {
                                enabled: false
                            }
                        },
                        {
                            type:'pie',
                            name: 'Children',
                            data: this._childChartData,
                            size: height,
                            innerSize: 0.8 * height,
                            allowPointSelect: false,
                            dataLabels: { enabled: false }
                        }
                    ]
                },

                chartConfig: {
                    chart: {
                        type: 'pie',
                        height: height,
                        width: this.width,
                        spacingTop: 0,
                        spacingRight: 0,
                        spacingBottom: 0,
                        spacingLeft: 0,
                        events: {
                            click: clickChartHandler
                        }
                    },
                    tooltip: {
                        formatter: function() {
                            return false;
                        }
                    },
                    spacingTop: 0,
                    title: { text: null },
                    plotOptions: {
                        pie: {
                            shadow: false,
                            center: ['50%', '50%'],
                            point: {
                                events: {
                                    click: clickChartHandler
                                }
                            },
                            showInLegend: false
                        }
                    }
                }
            }, overrides || {});
        },

        _addPointForTopLevelItem: function(record, relatedCount) {
            var blocked = record.get('Blocked');
            var color = this._colorFromStatus(this._storyStates[record.get('ScheduleState')], blocked);
            var pointSize = record.get('PlanEstimate') || 1;

            this._chartData.push({
                name: record.get('FormattedID'),
                y: pointSize,
                color: color,
                rallyName: record.get('Name'),
                status: record.get('ScheduleState'),
                blocked: blocked,
                blockedReason: blocked ? record.get('BlockedReason') : null,
                hasChildren: relatedCount > 0,
                relatedCount: relatedCount,
                ref: record.get('_ref'),
                parentFormattedID: null
            });
        },

        _addPointForChildItem: function(parentFormattedID, pointSize, state, blocked) {
            var color = this._colorFromStatus(this._storyStates[state], blocked);

            this._childChartData.push({
                y: pointSize,
                color: color,
                status: state,
                blocked: blocked,
                hasChildren: false,
                relatedCount: 0,
                parentFormattedID: parentFormattedID
            });
        }
      
    });
})();

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialogChartToggle', {
        requires:['Rally.ui.Button'],
        extend:'Ext.Container',
        alias:'widget.iterationprogressdialogcharttoggle',
        
        componentCls: 'iteration-progress-toggle-button-group',
        layout: 'hbox',
        border: 1,
        width: 106,
        activeButtonCls: 'active',

        defaultType: 'rallybutton',

        config: {
            startingIndex: 0
        },
        
        items: [{
            cls: 'toggle left pie-chart',
            iconCls: 'icon-pie',
            frame: false,
            toggleGroup: 'iterationprogressviewtoggle',
            style: {
                fontSize: '15px'
            },
            toolTipConfig: {
                html: 'Pie',
                anchor: 'top',
                hideDelay: 0
            },
            userAction:'IterationProgressApp - User clicked pie chart'
        },
        {
            cls: 'toggle center burndown',
            iconCls: 'icon-bars',
            frame: false,
            toggleGroup: 'iterationprogressviewtoggle',
            toolTipConfig: {
                html: 'Burndown',
                anchor: 'top',
                hideDelay: 0
            },
            userAction:'IterationProgressApp - User clicked burndown'
        },
        {
            cls: 'toggle right cumulativeflow',
            iconCls: 'icon-graph',
            frame: false,
            toggleGroup: 'iterationprogressviewtoggle',
            toolTipConfig: {
                html: 'Cumulative Flow',
                anchor: 'top',
                hideDelay: 0
            },
            userAction:'IterationProgressApp - User clicked CFD'
        }],

        initComponent: function(config) {
            this.initConfig(config);
            this.callParent(arguments);

            this.addEvents([
                /**
                 * @event toggle
                 * Fires when the toggle value is changed.
                 * @param {String} toggleState 'burndown' or 'cumulativeflow' or 'pie'.
                 */
                'toggle'
            ]);

            this.items.each(function(item) {
                item.on('click', this._onButtonClick, this);
            }, this);

            this.setCurrentItem(this.startingIndex);
        },

        _onButtonClick: function(btn) {
            var btnIndex = this.items.indexOf(btn);
            if (btnIndex !== this._activeIndex) {
                this._setActive(btn);
                this.fireEvent('toggle', this, btnIndex);
            }
        },

        _setActive: function(btn) {
            this.items.each(function(item, btnIndex) {
                if (item === btn) {
                    if (!item.hasCls(this.activeButtonCls.split(' ')[0])) {
                        item.addCls(this.activeButtonCls);
                        this._activeIndex = btnIndex;
                    }
                } else {
                    item.removeCls(this.activeButtonCls);
                }
            }, this);
        },

        setCurrentItem: function(itemIndex) {
            this._setActive(this.items.get(itemIndex));
        }
    });
})();


                (function(){

    var Ext = window.Ext4 || window.Ext;

    /**
    * shows burndown for timebox
    */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog', {
        extend: 'Rally.ui.dialog.Dialog',
        alias:'widget.statsbanneriterationprogressdialog',
        requires: [
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialogChartToggle',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart',
            'Rally.ui.carousel.Carousel'
        ],
        config: {
            startingIndex: 0,
            autoShow: true,
            draggable: true,
            disableScroll: true,
            width: 820,
            height: 650,
            closable: true,
            store: null,
            context: null
        },
        layout: {
            type: 'vbox',
            align: 'center'
        },
        cls: 'iteration-progress-dialog',

        constructor: function (config){
            this.initConfig(config || {});
            this.callParent(arguments);
        },

        initComponent: function(){
            var chartWidth = 704;
            var chartHeight = 570;

            this.callParent(arguments);
            this.toggle = this.add({
                xtype: 'iterationprogressdialogcharttoggle',
                startingIndex: this.startingIndex,
                listeners: {
                    toggle: this._toggleButtonClick,
                    scope: this
                }
            });
            this.carousel = this.add({
                xtype: 'rallycarousel',
                showDots: false,
                enableAnimations: false,
                carouselItems: [
                    {
                        xtype: 'statsbannerpiechart',
                        width: chartWidth,
                        height: chartHeight,
                        context: this.context
                    },
                    {
                        xtype: 'statsbannerburndownchart',
                        width: chartWidth,
                        height: chartHeight,
                        context: this.context,
                        store: this.store
                    },
                    {
                        xtype: 'statsbannercumulativeflowchart',
                        width: chartWidth,
                        height: chartHeight,
                        context: this.context,
                        store: this.store
                    }
                ],
                startingIndex: this.startingIndex,
                listeners: {
                    carouselmove: {
                        fn: this._onCarouselMove,
                        scope: this
                    },
                    afterlayout: {
                        fn: this._afterLayout,
                        single: true,
                        scope: this
                    }
                }
            });
        },

        _toggleButtonClick: function(toggleBtnContainer, buttonIndex){
            this._setChart(buttonIndex);
        },

        _afterLayout: function(){
            Ext.defer(this._setChart, 10, this, [this.startingIndex]);
        },

        _setChart: function(chartIndex) {
            this.carousel.setCurrentItem(chartIndex);
            this.toggle.setCurrentItem(chartIndex);
            // need to bypass the setTitle method as it causes a relayout of the page messing up the carousel
            this.header.titleCmp.textEl.update(this.carousel.getCurrentItem().displayTitle);
        },

        _onCarouselMove: function(carousel){
            this._setChart(carousel.getCurrentItemIndex());
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows burndown for timebox
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.IterationProgress', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbanneriterationprogress',
        requires: [
            'Rally.ui.carousel.Carousel',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.BurndownChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.CumulativeFlowChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.MinimalPieChart',
            'Rally.apps.iterationtrackingboard.statsbanner.iterationprogresscharts.PieChart',
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog',
            'Ext.state.Manager'
        ],

        config: {
            context: null,
            store: null
        },

        currentChartDisplayed: 1,

        stateId: 'stats-banner-iteration-progress',
        stateful: true,

        clientMetrics: {
            method: '_onChartClick',
            description: 'opened IterationProgressDialog'
        },

        tpl: [
            '<div class="expanded-widget">',
            '<div class="stat-title"></div>',
            '<div class="stat-metric">',
            '<div class="stat-carousel"></div>',
            '</div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<span class="metric-icon icon-pie"></span>',
            '<div class="stat-title"></div>',
            '</div>'
        ],

        constructor: function(config) {
            this.stateId = Rally.environment.getContext().getScopedStateId(this.stateId);
            this.callParent(arguments);
        },

        initComponent: function(){
            this.mon(this.store, 'datachanged', this.onDataChanged, this);
            this.callParent(arguments);
            var boundClickHandler = Ext.bind(this._onChartClick, this);

            this.carouselItems = [
                {
                    xtype: 'statsbannerminimalpiechart',
                    width: 150,
                    height: 60,
                    minimalMode: true,
                    clickHandler: boundClickHandler,
                    context: this.context,
                    store: this.store
                },
                {
                    xtype: 'statsbannerburndownchart',
                    width: 150,
                    height: 63,
                    minimalMode: true,
                    clickHandler: boundClickHandler,
                    context: this.context,
                    store: this.store
                },
                {
                    xtype: 'statsbannercumulativeflowchart',
                    width: 150,
                    height: 63,
                    minimalMode: true,
                    clickHandler: boundClickHandler,
                    context: this.context,
                    store: this.store
                }
            ];

            _.each(this.carouselItems, function(carouselItem) {
                carouselItem.listeners = {
                    ready: this._onChartReady,
                    scope: this
                };
            }, this);

            this._pendingChartReadies = this.carouselItems.length;
        },

        expand: function() {
            this.callParent();
            // Carousel was updated while hidden so it needs to die
            // and we create a new one since it can't lay itself out
            if (!this.carousel || this.carousel.getWidth() === 0) {
                this.onDataChanged();
            }
        },

        _onChartReady: function() {
            this._pendingChartReadies -= 1;
            if (this._pendingChartReadies === 0) {
                this.fireEvent('ready', this);
            }
        },

        _onChartClick: function() {
            var currentIndex = this.carousel.getCurrentItemIndex();
            Ext.create('Rally.apps.iterationtrackingboard.statsbanner.IterationProgressDialog', {
                startingIndex: currentIndex,
                store: this.store,
                context: this.context
            });
        },

        _cleanupCarousel: function () {
            if (this.carousel) {
                this.carousel.destroy();
                delete this.carousel;
            }
        },

        onDestroy: function () {
            this._cleanupCarousel();
            this.callParent(arguments);
        },

        onRender: function() {
            this.callParent(arguments);
            if (!this.getContext().getTimeboxScope().getRecord()) {
                this._addPlaceholder();
            }
        },

        applyState: function (state) {
            if (state){
                if (state.currentChartDisplayed > this.carouselItems.length -1 || state.currentChartDisplayed < 0) {
                    this.currentChartDisplayed = 1;
                } else {
                    this.currentChartDisplayed = state.currentChartDisplayed;
                }
            }
        },

        getState: function(){
            return {
                currentChartDisplayed: this.currentChartDisplayed
            };
        },

        onDataChanged: function() {
            this._cleanupCarousel();

            if(this.rendered) {
                if (this.getContext().getTimeboxScope().getRecord()) {
                    this.update();

                    this.createCarousel();
                } else {
                    this._addPlaceholder();
                }
            }
        },

        createCarousel: function() {
            this.carousel = Ext.create('Rally.ui.carousel.Carousel', {
                showHeader: false,
                showDots: true,
                smallDots: true,
                renderTo: this.getEl().down('.stat-carousel'),
                height: 75,
                layout: {
                    type: 'vbox',
                    align: 'center'
                },
                listeners: {
                    currentitemset: this._updateTitle,
                    carouselmove: this._updateTitle,
                    scope: this
                },
                carouselItems: this.carouselItems
            });

            if (!Ext.isIE8m){
                // if such next line runs IE8 or < goes boom! WOW!
                this.carousel.setCurrentItem(this.currentChartDisplayed);
            }

            this.carousel.on('carouselmove', this._chartShownChanged, this);
        },

        _updateTitle: function(carousel){
            _.each(this.getEl().query('.stat-title'), function(el){
                Ext.fly(el).update(carousel.getCurrentItem().displayTitle);
            }, this);
        },

        _chartShownChanged: function(){
            var chartShown = _.findIndex(this.carouselItems, {xtype: this.carousel.getCurrentItem().xtype});
            this.currentChartDisplayed = chartShown || 0;
            this.saveState();
        },

        _addPlaceholder: function() {
            this.update();

            if (this.expanded) {
                this.carousel = Ext.create('Ext.Container', {
                    renderTo: this.getEl().down('.stat-carousel'),
                    html: 'no iteration data'
                });
            }
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * shows collapse/expand toggle for stats banner
     */
    Ext.define('Rally.apps.iterationtrackingboard.statsbanner.CollapseExpand', {
        extend: 'Rally.apps.iterationtrackingboard.statsbanner.BannerWidget',
        alias:'widget.statsbannercollapseexpand',
        requires: [],

        tpl: [
            '<div class="expanded-widget">',
            '<div class="toggle-icon icon-chevron-up"></div>',
            '</div>',
            '<div class="collapsed-widget">',
            '<div class="toggle-icon icon-chevron-down"></div>',
            '</div>'
        ],

        componentCls: 'collapse-expand',

        bubbleEvents: ['collapse', 'expand'],

        afterRender: function() {
            this.callParent(arguments);
            this.getEl().on('click', this._onCollapseExpandClick, this);
            this.fireEvent('ready', this);
        },

        _onCollapseExpandClick: function() {
            if (this.expanded) {
                this.fireEvent('collapse', this);
            } else {
                this.fireEvent('expand', this);
            }
        },

        expand: function() {
            this.callParent(arguments);
            this.doComponentLayout();
        },

        collapse: function() {
            this.callParent(arguments);
            this.doComponentLayout();
        }
    });
})();
                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * Allows user to see stats for a timebox in a horizontal bar format
     */
    Ext.define('Rally.apps.iterationtrackingboard.StatsBanner', {
        extend: 'Ext.Container',
        alias:'widget.statsbanner',
        requires: [
            'Rally.Message',
            'Rally.apps.iterationtrackingboard.statsbanner.PlannedVelocity',
            'Rally.apps.iterationtrackingboard.statsbanner.TimeboxEnd',
            'Rally.apps.iterationtrackingboard.statsbanner.Defects',
            'Rally.apps.iterationtrackingboard.statsbanner.Accepted',
            'Rally.apps.iterationtrackingboard.statsbanner.Tasks',
            'Rally.apps.iterationtrackingboard.statsbanner.IterationProgress',
            'Rally.apps.iterationtrackingboard.statsbanner.CollapseExpand'
        ],
        mixins: [
            'Rally.Messageable',
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],
        cls: 'stats-banner',
        layout: 'hbox',
        border: 0,
        width: '100%',
        stateful: true,
        stateEvents: ['expand', 'collapse'],

        config: {
            context: null,
            expanded: true
        },

        items: [
            {xtype: 'statsbannerplannedvelocity'},
            {xtype: 'statsbannertimeboxend'},
            {xtype: 'statsbanneraccepted'},
            {xtype: 'statsbannerdefects'},
            {xtype: 'statsbannertasks'},
            {xtype: 'statsbanneriterationprogress', flex: 2},
            {xtype: 'statsbannercollapseexpand', flex: 0}
        ],

        constructor: function() {
            this.stateId = Rally.environment.getContext().getScopedStateId('stats-banner');
            this.callParent(arguments);
        },

        initComponent: function() {
            this.addEvents(
                /**
                 * @event
                 * Fires when expand is clicked
                 */
                'expand',
                /**
                 * @event
                 * Fires when collapse is clicked
                 */
                'collapse'
            );

            this.subscribe(this, Rally.Message.objectDestroy, this._update, this);
            this.subscribe(this, Rally.Message.objectCreate, this._update, this);
            this.subscribe(this, Rally.Message.objectUpdate, this._update, this);
            this.subscribe(this, Rally.Message.bulkUpdate, this._update, this);
            this.subscribe(this, Rally.Message.bulkImport, this._update, this);

            this.store = Ext.create('Rally.data.wsapi.artifact.Store', {
                models: ['User Story', 'Defect', 'Defect Suite', 'Test Set'],
                fetch: ['Defects:summary[State;ScheduleState+Blocked]', 'PlanEstimate', 'Requirement', 'FormattedID', 'Name', 'Blocked', 'BlockedReason',
                    'ScheduleState', 'State', 'Tasks:summary[State+Blocked]', 'TestCases'],
                useShallowFetch: true,
                filters: [this.context.getTimeboxScope().getQueryFilter()],
                context: this.context.getDataContext(),
                limit: Infinity,
                requester: this
            });

            //need to configure the items at the instance level, not the class level (i.e. don't use the 'defaults' config)
            this.items = this._configureItems(this.items);

            this.on('expand', this._onExpand, this);
            this.on('collapse', this._onCollapse, this);
            this.callParent(arguments);

            this._update();
        },

        onRender: function() {
            if (this.expanded) {
                this.removeCls('collapsed');
            } else {
                this.addCls('collapsed');
            }
            this._setExpandedOnChildItems();
            this.callParent(arguments);
        },

        applyState: function (state) {
            if (Ext.isDefined(state.expanded)) {
                this.setExpanded(state.expanded);
            }
            this._setExpandedOnChildItems();
        },

        getState: function(){
            return {
                expanded: this.expanded
            };
        },

        _setExpandedOnChildItems: function() {
            _.each(this.items.getRange(), function(item) {
                item.setExpanded(this.expanded);
            }, this);
        },

        _getItemDefaults: function() {
            return {
                flex: 1,
                context: this.context,
                store: this.store,
                listeners: {
                    ready: this._onReady,
                    scope: this
                }
            };
        },

        _onReady: function() {
            this._readyCount = (this._readyCount || 0) + 1;
            if(this._readyCount === this.items.getCount()) {
                this.recordComponentReady();
                delete this._readyCount;
            }
        },

        _onCollapse: function() {
            this.addCls('collapsed');
            this.setExpanded(false);

            _.invoke(this.items.getRange(), 'collapse');
        },

        _onExpand: function() {
            this.removeCls('collapsed');
            this.setExpanded(true);

            _.invoke(this.items.getRange(), 'expand');
        },

        _hasTimebox: function() {
            return !!this.context.getTimeboxScope().getRecord();
        },

        _configureItems: function(items) {
            var defaults = this._getItemDefaults();

            return _.map(items, function(item) {
                return _.defaults(_.cloneDeep(item), defaults);
            });
        },

        _update: function () {
            if(this._hasTimebox()) {
                this.store.load();
            }
        }
    });
})();

                (function() {
    var Ext = window.Ext4 || window.Ext;

    /**
     * @private
     * Allows displaying the stats banner settings
     *
     *
     *      @example
     *      Ext.create('Ext.Container', {
         *          items: [{
         *              xtype: 'rallystatsbannersettingsfield',
         *              value: {
         *                  showStatsBanner: true
         *              }
         *          }],
         *          renderTo: Ext.getBody().dom
         *      });
     *
     */
    Ext.define('Rally.apps.iterationtrackingboard.StatsBannerField', {
        extend: 'Ext.form.FieldContainer',
        requires: [
            'Rally.ui.CheckboxField'
        ],
        alias: 'widget.rallystatsbannersettingsfield',

        mixins: {
            field: 'Ext.form.field.Field'
        },

        layout: 'hbox',

        cls: 'stats-banner-settings',

        config: {
            /**
             * @cfg {Object}
             *
             * The column settings value for this field
             */
            value: undefined
        },

        initComponent: function() {
            this.callParent(arguments);

            this.mixins.field.initField.call(this);

            this.add([
                {
                    xtype: 'rallycheckboxfield',
                    name: 'showStatsBanner',
                    boxLabel: 'Show the Iteration Progress Banner',
                    submitValue: false,
                    margin: '0 0 0 80',
                    value: this.getValue().showStatsBanner
                }
            ]);
        },

        /**
         * When a form asks for the data this field represents,
         * give it the name of this field and the ref of the selected project (or an empty string).
         * Used when persisting the value of this field.
         * @return {Object}
         */
        getSubmitData: function() {
            var data = {};
            var showStatsBannerField = this.down('rallycheckboxfield');
            data[showStatsBannerField.name] = showStatsBannerField.getValue();
            return data;
        }
    });
})();



                (function(){

    var Ext = window.Ext4 || window.Ext;

    /**
    * shows print dialog for Iteration Progress App
    */
    Ext.define('Rally.apps.iterationtrackingboard.PrintDialog', {
        extend: 'Rally.ui.dialog.Dialog',
        alias:'widget.iterationprogessappprintdialog',
        requires: [
            'Rally.ui.Button'
        ],
        config: {
            autoShow: true,
            draggable: true,
            disableScroll: true,
            width: 520,
            height: 300,
            closable: true,
            title: 'Print'
        },
        layout: {
            type: 'vbox',
            align: 'left'
        },
        cls: 'iteration-progress-dialog print-dialog',
        items: [
            {
                xtype: 'container',
                html: 'What would you like to print?',
                cls: 'dialog-title'
            },
            {
                xtype: 'radiogroup',
                id: 'whattoprint',
                vertical: true,
                columns: 1,
                height: 70,
                width: 470,
                items: [
                    {
                        boxLabel: 'Summary list of work items',
                        name: 'reportType',
                        inputValue: 'summary',
                        checked: true
                    },
                    {
                        boxLabel: 'Summary list of work items with children',
                        id: 'printDialogReportTypeIncludeChildren',
                        name: 'reportType',
                        inputValue: 'includechildren'
                    }
                ]
            }
        ],
        constructor: function(config) {
            this.initConfig(config || {});
            this.timeboxScope = this.config.timeboxScope;

            this.nodesToExpand = [];
            this.allRecords = [];

            this.callParent(arguments);
        },

        initComponent: function() {
            var warningTextClasses = this.showWarning ? 'print-warning' : 'print-warning hidden';
            this.items.push({
                xtype: 'container',
                html: '<div class="icon-warning alert"></div> Print is limited to 200 work items.',
                cls: warningTextClasses,
                itemId: 'tooManyItems'
            });

            this.dockedItems = [{
                xtype: 'toolbar',
                dock: 'bottom',
                layout: {
                    type: 'hbox',
                    pack: 'center'
                },
                ui: 'footer',
                itemId: 'footer',
                defaults: {
                    xtype: 'rallybutton',
                    padding: '4 12',
                    scope: this
                },
                items: [
                    {
                        text: 'Print',
                        cls: 'primary medium',
                        handler: this._handlePrintClick
                    },
                    {
                        text: 'Cancel',
                        cls: 'secondary medium',
                        handler: this._handleCancelClick
                    }
                ]
            }];

            this.callParent(arguments);
        },

        _handlePrintClick: function() {
            var treeStoreBuilder = Ext.create('Rally.data.wsapi.TreeStoreBuilder');
            var storeConfig = this._buildStoreConfig();

            treeStoreBuilder.build(storeConfig);
        },

        _handleCancelClick: function(target, e) {
            this.destroy();
        },

        _buildStoreConfig: function() {
            var timeboxFilter = this.timeboxScope.getQueryFilter();
            var includeChildren = Ext.getCmp('whattoprint').getChecked()[0].inputValue === 'includechildren';

            return {
                models: ['User Story', 'Defect', 'Defect Suite', 'Test Set'],
                autoLoad: true,
                pageSize: 200,
                remoteSort: true,
                root: {expanded: includeChildren},
                enableHierarchy: includeChildren,
                childPageSizeEnabled: false,
                filters: [timeboxFilter],
                sorters: this.grid.getStore().getSorters(),
                listeners: {
                    load: this._onStoreLoad,
                    scope: this
                }
            };
        },

        _onStoreLoad: function(treeStore, node, records, success, eOpts) {
            if (_.isEmpty(this.allRecords)) {
                this.allRecords = records;
            }

            if (treeStore.enableHierarchy) {
                this.nodesToExpand = _.without(this.nodesToExpand, node.getId());

                _(records).filter(function(record) {
                    return !record.isLeaf();
                }).forEach(function(record) {
                    this.nodesToExpand.push(record.getId());
                    record.expand(true);
                }, this);
            }

            if (_.isEmpty(this.nodesToExpand)) {
                this._onDataReady();
            }
        },

        _onDataReady: function() {
            var timeboxScopeRecord = this.timeboxScope.getRecord();
            var iterationName = timeboxScopeRecord ? timeboxScopeRecord.get('Name') : 'Unscheduled';
            var treeGridPrinter = Ext.create('Rally.ui.grid.TreeGridPrinter', {
                records: this.allRecords,
                grid: this.grid,
                iterationName: iterationName
            });
            var win = Rally.getWindow();

            if(win.printWindow) {
                win.printWindow.close();
            }

            win.printWindow = win.open(Rally.environment.getServer().getContextUrl() + '/print/printContainer.html', 'printWindow', 'height=600,width=1000,toolbar=no,menubar=no,scrollbars=yes');
            if (!win.printWindow) {
                alert('It looks like you have a popup blocker installed. Please turn this off to see the print window.');
                return;
            }
            treeGridPrinter.print(win.printWindow);
            win.printWindow.focus();

            this.destroy();
        }
    });
})();

                (function () {
    var Ext = window.Ext4 || window.Ext;

    var defaultGridColumns = ['Name', 'ScheduleState', 'Blocked', 'PlanEstimate', 'TaskStatus', 'TaskEstimateTotal', 'TaskRemainingTotal', 'Owner', 'DefectStatus', 'Discussion'];

    /**
     * Iteration Tracking Board App
     * The Iteration Tracking Board can be used to visualize and manage your User Stories and Defects within an Iteration.
     */
    Ext.define('Rally.apps.iterationtrackingboard.IterationTrackingBoardApp', {
        extend: 'Rally.app.TimeboxScopedApp',
        requires: [
            'Rally.data.Ranker',
            'Rally.data.WsapiModelFactory',
            'Rally.data.wsapi.TreeStoreBuilder',
            'Rally.ui.dialog.CsvImportDialog',
            'Rally.ui.gridboard.GridBoard',
            'Rally.apps.iterationtrackingboard.IterationTrackingTreeGrid',
            'Rally.ui.cardboard.plugin.FixedHeader',
            'Rally.ui.cardboard.plugin.Print',
            'Rally.ui.gridboard.plugin.GridBoardActionsMenu',
            'Rally.ui.gridboard.plugin.GridBoardAddNew',
            'Rally.ui.gridboard.plugin.GridBoardCustomFilterControl',
            'Rally.ui.gridboard.plugin.GridBoardOwnerFilter',
            'Rally.ui.gridboard.plugin.GridBoardFilterInfo',
            'Rally.ui.gridboard.plugin.GridBoardArtifactTypeChooser',
            'Rally.ui.gridboard.plugin.GridBoardFieldPicker',
            'Rally.ui.cardboard.plugin.ColumnPolicy',
            'Rally.ui.gridboard.plugin.GridBoardFilterInfo',
            'Rally.ui.gridboard.plugin.GridBoardFilterControl',
            'Rally.ui.gridboard.plugin.GridBoardToggleable',
            'Rally.ui.grid.plugin.TreeGridExpandedRowPersistence',
            'Rally.ui.grid.plugin.TreeGridChildPager',
            'Rally.ui.gridboard.plugin.GridBoardExpandAll',
            'Rally.ui.gridboard.plugin.GridBoardCustomView',
            'Rally.ui.filter.view.ModelFilter',
            'Rally.ui.filter.view.OwnerFilter',
            'Rally.ui.filter.view.OwnerPillFilter',
            'Rally.ui.filter.view.TagPillFilter',
            'Rally.app.Message',
            'Rally.apps.iterationtrackingboard.Column',
            'Rally.apps.iterationtrackingboard.StatsBanner',
            'Rally.apps.iterationtrackingboard.StatsBannerField',
            'Rally.clientmetrics.ClientMetricsRecordable',
            'Rally.apps.iterationtrackingboard.PrintDialog',
            'Rally.ui.grid.plugin.ColumnAutoSizer'
        ],

        mixins: [
            'Rally.app.CardFieldSelectable',
            'Rally.clientmetrics.ClientMetricsRecordable'
        ],
        componentCls: 'iterationtrackingboard',
        alias: 'widget.rallyiterationtrackingboard',

        settingsScope: 'project',
        userScopedSettings: true,
        scopeType: 'iteration',
        autoScroll: false,

        config: {
            defaultSettings: {
                showCardAge: true,
                showStatsBanner: true,
                cardAgeThreshold: 3
            }
        },

        modelNames: ['User Story', 'Defect', 'Defect Suite', 'Test Set'],

        onScopeChange: function() {
            if(!this.rendered) {
                this.on('afterrender', this.onScopeChange, this, {single: true});
                return;
            }

            var grid = this.down('rallytreegrid');
            if (grid) {
                // reset page count to 1.
                // must be called here to reset persisted page count value.
                grid.fireEvent('storecurrentpagereset');
            }

            if(this._shouldShowStatsBanner()){
                this._addStatsBanner();
            }

            this._buildGridStore().then({
                success: function(gridStore) {
                    var model = gridStore.model;
                    if(_.isFunction(model.getArtifactComponentModels)) {
                        this.modelNames = _.intersection(_.pluck(gridStore.model.getArtifactComponentModels(),'displayName'),this.modelNames);
                    } else {
                        this.modelNames = [model.displayName];
                    }
                    this._addGridBoard(gridStore);
                },
                scope: this
            });
        },

        getSettingsFields: function () {
            var fields = this.callParent(arguments);

            fields.push({
                type: 'cardage',
                config: {
                    margin: '0 0 0 80',
                    width: 300
                }
            });

            return fields;
        },

        getUserSettingsFields: function () {
            var fields = this.callParent(arguments);

            fields.push({
                xtype: 'rallystatsbannersettingsfield',
                fieldLabel: '',
                mapsToMultiplePreferenceKeys: ['showStatsBanner']
            });

            return fields;
        },

        _buildGridStore: function() {
            var context = this.getContext(),
                config = {
                    models: this.modelNames,
                    autoLoad: false,
                    remoteSort: true,
                    root: {expanded: true},
                    enableHierarchy: true,
                    pageSize: this.getGridPageSizes()[1],
                    childPageSizeEnabled: context.isFeatureEnabled('EXPAND_ALL_TREE_GRID_CHILDREN'),
                    useShallowFetch: context.isFeatureEnabled('COMPACT_WSAPI_REQUESTS') ? false : true
                };

            if(!context.isFeatureEnabled('USE_CUSTOM_FILTER_POPOVER_ON_ITERATION_TRACKING_APP')) {
                config.filters = [context.getTimeboxScope().getQueryFilter()];
            }

            return Ext.create('Rally.data.wsapi.TreeStoreBuilder').build(config);
        },

        _shouldShowStatsBanner: function() {
            return this.getSetting('showStatsBanner');
        },

        _addStatsBanner: function() {
           this.remove('statsBanner');
           this.add({
                xtype: 'statsbanner',
                itemId: 'statsBanner',
                context: this.getContext(),
                margin: '0 0 5px 0',
                listeners: {
                    resize: this._resizeGridBoardToFillSpace,
                    scope: this
                }
            });
        },

        _addGridBoard: function (gridStore) {
            var context = this.getContext();

            this.remove('gridBoard');

            this.gridboard = this.add({
                itemId: 'gridBoard',
                xtype: 'rallygridboard',
                stateId: 'iterationtracking-gridboard',
                context: context,
                plugins: this._getGridBoardPlugins(),
                modelNames: this.modelNames,
                useFilterCollection: !context.isFeatureEnabled('USE_CUSTOM_FILTER_POPOVER_ON_ITERATION_TRACKING_APP'),
                cardBoardConfig: this._getBoardConfig(),
                gridConfig: this._getGridConfig(gridStore),
                storeConfig: {
                    useShallowFetch: context.isFeatureEnabled('COMPACT_WSAPI_REQUESTS') ? false : true,
                    filters: [context.getTimeboxScope().getQueryFilter()]
                },
                addNewPluginConfig: {
                    style: {
                        'float': 'left'
                    }
                },
                listeners: {
                    load: this._onLoad,
                    toggle: this._onToggle,
                    recordupdate: this._publishContentUpdatedNoDashboardLayout,
                    recordcreate: this._publishContentUpdatedNoDashboardLayout,
                    scope: this
                },
                height: Math.max(this.getAvailableGridBoardHeight(), 150)
            });
        },

        _getBoardConfig: function() {
            return {
                serverSideFiltering: this.getContext().isFeatureEnabled('BETA_TRACKING_EXPERIENCE'),
                plugins: [
                    {ptype: 'rallycardboardprinting', pluginId: 'print'},
                    {ptype: 'rallyfixedheadercardboard'}
                ],
                columnConfig: {
                    xtype: 'iterationtrackingboardcolumn',
                    additionalFetchFields: ['PortfolioItem'],
                    plugins: [{
                        ptype: 'rallycolumnpolicy',
                        app: this
                    }]
                },
                cardConfig: {
                    showAge: this.getSetting('showCardAge') ? this.getSetting('cardAgeThreshold') : -1
                },
                listeners: {
                    filter: this._onBoardFilter,
                    filtercomplete: this._onBoardFilterComplete
                }
            };
        },

        /**
         * @private
         */
        getAvailableGridBoardHeight: function() {
            var height = this.getHeight();
            if(this._shouldShowStatsBanner() && this.down('#statsBanner').rendered) {
                height -= this.down('#statsBanner').getHeight();
            }
            return height;
        },

        _getGridBoardPlugins: function() {
            var plugins = ['rallygridboardaddnew'];
            var context = this.getContext();

            if (context.isFeatureEnabled('EXPAND_ALL_TREE_GRID_CHILDREN') && !Ext.isIE) {
                plugins.push('rallygridboardexpandall');
            }

            if (context.isFeatureEnabled('BETA_TRACKING_EXPERIENCE')) {
                var filterControlConfig = {
                    cls: 'small gridboard-filter-control',
                    context: context,
//                    margin: '3 10 3 7',
                    stateful: true
                };

                if (context.isFeatureEnabled('USE_CUSTOM_FILTER_POPOVER_ON_ITERATION_TRACKING_APP')) {
                    plugins.push({
                        ptype: 'rallygridboardcustomfiltercontrol',
                        filterChildren: this.getContext().isFeatureEnabled('S58650_ALLOW_WSAPI_TRAVERSAL_FILTER_FOR_MULTIPLE_TYPES'),
                        filterControlConfig: _.merge(filterControlConfig, {
                            blackListFields: [
                                'DirectChildrenCount',
                                'DisplayColor',
                                'DragAndDropRank',
                                'Iteration',
                                'PortfolioItem',
                                'TestCase',
                                'TestCaseResult',
                                'VersionId'
                            ],
                            whiteListFields: [
                                'Tags'
                            ],
                            modelNames: this.modelNames,
                            stateId: context.getScopedStateId('iteration-tracking-custom-filter-button')
                        })
                    });
                } else {
                    plugins.push({
                        ptype: 'rallygridboardfiltercontrol',
                        filterControlConfig: _.merge(filterControlConfig, {
                            items: [
                                this._createOwnerFilterItem(context),
                                this._createTagFilterItem(context),
                                this._createModelFilterItem(context)
                            ],
                            stateId: context.getScopedStateId('iteration-tracking-filter-button')
                        })
                    });
                }
            } else {
                plugins.push('rallygridboardownerfilter');
            }

            plugins.push('rallygridboardtoggleable');

            var actionsMenuItems = [
            {
                text: 'Import User Stories...',
                handler: this._importHandler({
                    type: 'userstory',
                    title: 'Import User Stories'
                })
            }, {
                text: 'Import Tasks...',
                handler: this._importHandler({
                    type: 'task',
                    title: 'Import Tasks'
                })
            }, {
                text: 'Export...',
                handler: this._exportHandler,
                scope: this
            }];
            if (context.isFeatureEnabled('S68103_ITERATION_TRACKING_APP_PRINT')) {
                actionsMenuItems.push({
                    text: 'Print...',
                    handler: this._printHandler,
                    scope: this
                });
            }
            plugins.push({
                ptype: 'rallygridboardactionsmenu',
                itemId: 'printExportMenuButton',
                menuItems: actionsMenuItems,
                buttonConfig: {
                    iconCls: 'icon-export',
                    toolTipConfig: {
                        html: 'Import/Export/Print',
                        anchor: 'top',
                        hideDelay: 0
                    }
                }
            });

            var alwaysSelectedValues = ['FormattedID', 'Name', 'Owner'];
            if (context.getWorkspace().WorkspaceConfiguration.DragDropRankingEnabled) {
                alwaysSelectedValues.push('DragAndDropRank');
            }

            if (!context.isFeatureEnabled('BETA_TRACKING_EXPERIENCE')) {
                plugins.push({
                    ptype: 'rallygridboardfilterinfo',
                    isGloballyScoped: Ext.isEmpty(this.getSetting('project')),
                    stateId: 'iteration-tracking-owner-filter-' + this.getAppId()
                });
            }

            plugins.push({
                ptype: 'rallygridboardfieldpicker',
                headerPosition: 'left',
                gridFieldBlackList: [
                    'ObjectID',
                    'Description',
                    'DisplayColor',
                    'Notes',
                    'Subscription',
                    'Workspace',
                    'Changesets',
                    'RevisionHistory',
                    'Children',
                    'Successors',
                    'Predecessors'
                ],
                boardFieldBlackList: [
                    'ObjectID',
                    'Description',
                    'DisplayColor',
                    'Notes',
                    'Rank',
                    'DragAndDropRank',
                    'Subscription',
                    'Workspace',
                    'Changesets',
                    'RevisionHistory',
                    'PortfolioItemType',
                    'StateChangedDate',
                    'Children',
                    'PredecessorsAndSuccessors'
                ],
                alwaysSelectedValues: alwaysSelectedValues,
                modelNames: this.modelNames,
                boardFieldDefaults: (this.getSetting('cardFields') && this.getSetting('cardFields').split(',')) ||
                    ['Parent', 'Tasks', 'Defects', 'Discussion', 'PlanEstimate', 'Iteration']
            });

            if (context.isFeatureEnabled('ITERATION_TRACKING_CUSTOM_VIEWS')) {
                plugins.push(this._getCustomViewConfig());
            }

            return plugins;
        },

        setHeight: Ext.Function.createBuffered(function() {
            this.superclass.setHeight.apply(this, arguments);
            this._resizeGridBoardToFillSpace();
        }, 100),

        _importHandler: function(options) {
            return _.bind(function() {
                Rally.data.WsapiModelFactory.getModel({
                    type: options.type,
                    success: function(model) {
                        Ext.widget({
                            xtype: 'rallycsvimportdialog',
                            model: model,
                            title: options.title,
                            params: {
                                iterationOid: this._getIterationOid()
                            }
                        });
                    },
                    scope: this
                });
            }, this);
        },

        _exportHandler: function() {
            var context = this.getContext();
            var params = {
                cpoid: context.getProject().ObjectID,
                projectScopeUp: context.getProjectScopeUp(),
                projectScopeDown: context.getProjectScopeDown(),
                iterationKey: this._getIterationOid()
            };

            window.location = Ext.String.format('{0}/sc/exportCsv.sp?{1}',
                Rally.environment.getServer().getContextUrl(),
                Ext.Object.toQueryString(params)
            );
        },

        _printHandler: function() {
            var gridBoard = this.queryById('gridBoard');
            var gridOrBoard = gridBoard.getGridOrBoard();
            var totalRows = gridOrBoard.store.totalCount;
            var timeboxScope = this.getContext().getTimeboxScope();

            Ext.create('Rally.apps.iterationtrackingboard.PrintDialog', {
                showWarning: totalRows > 200,
                timeboxScope: timeboxScope,
                grid: gridOrBoard
            });
        },

        _getIterationOid: function() {
            var iterationId = '-1';
            var timebox = this.getContext().getTimeboxScope();

            if (timebox && timebox.getRecord()) {
                iterationId = timebox.getRecord().getId();
            }
            return iterationId;
        },

        _resizeGridBoardToFillSpace: function() {
            if (this.gridboard) {
                this.gridboard.setHeight(this.getAvailableGridBoardHeight());
            }
        },

        _getCustomViewConfig: function() {
            var customViewConfig = {
                ptype: 'rallygridboardcustomview',
                stateId: 'iteration-tracking-board-app',

                defaultGridViews: [{
                    model: ['UserStory', 'Defect', 'DefectSuite', 'TestSet'],
                    name: 'Defect Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'Discussion',
                                'Priority',
                                'Severity',
                                'FoundIn',
                                'FixedIn',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                defectstatusview: {
                                    isActiveFilter: false,
                                    itemId: 'defectstatusview',
                                    queryString: '((Defects.ObjectID != null) OR (Priority != null))'
                                }
                            }
                        }
                    }
                }, {
                    model: ['UserStory', 'Defect', 'TestSet', 'DefectSuite'],
                    name: 'Task Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'PlanEstimate',
                                'TaskEstimate',
                                'ToDo',
                                'Discussions',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                taskstatusview: {
                                    isActiveFilter: false,
                                    itemId: 'taskstatusview',
                                    queryString: '(Tasks.ObjectID != null)'
                                }
                            }
                        }
                    }
                }, {
                    model: ['UserStory', 'Defect', 'TestSet'],
                    name: 'Test Status',
                    state: {
                        cmpState: {
                            expandAfterApply: true,
                            columns: [
                                'Name',
                                'State',
                                'Discussions',
                                'LastVerdict',
                                'LastBuild',
                                'LastRun',
                                'ActiveDefects',
                                'Priority',
                                'Owner'
                            ]
                        },
                        filterState: {
                            filter: {
                                teststatusview: {
                                    isActiveFilter: false,
                                    itemId: 'teststatusview',
                                    queryString: '(TestCases.ObjectID != null)'
                                }
                            }
                        }
                    }
                }]
            };

            customViewConfig.defaultBoardViews = _.cloneDeep(customViewConfig.defaultGridViews);
            _.each(customViewConfig.defaultBoardViews, function(view) {
                delete view.state.cmpState;
            });

            return customViewConfig;
        },

        _createOwnerFilterItem: function (context) {
            var isPillPickerEnabled = context.isFeatureEnabled('BETA_TRACKING_EXPERIENCE'),
                projectRef = context.getProjectRef();

            if (isPillPickerEnabled) {
                return {
                    xtype: 'rallyownerpillfilter',
                    margin: '-15 0 5 0',
                    filterChildren: this.getContext().isFeatureEnabled('S58650_ALLOW_WSAPI_TRAVERSAL_FILTER_FOR_MULTIPLE_TYPES'),
                    project: projectRef,
                    showPills: false,
                    showClear: true
                };
            } else {
                return {
                    xtype: 'rallyownerfilter',
                    margin: '5 0 5 0',
                    filterChildren: this.getContext().isFeatureEnabled('S58650_ALLOW_WSAPI_TRAVERSAL_FILTER_FOR_MULTIPLE_TYPES'),
                    project: projectRef
                };
            }

        },

        _createTagFilterItem: function (context) {
            var filterUiImprovementsToggleEnabled = context.isFeatureEnabled('BETA_TRACKING_EXPERIENCE');
            return {
                xtype: 'rallytagpillfilter',
                margin: filterUiImprovementsToggleEnabled ? '-15 0 5 0' : '5 0 5 0',
                showPills: filterUiImprovementsToggleEnabled,
                showClear: filterUiImprovementsToggleEnabled,
                remoteFilter: filterUiImprovementsToggleEnabled
            };
        },

        _createModelFilterItem: function (context) {
            return {
                xtype: 'rallymodelfilter',
                models: this.modelNames,
                context: context
            };
        },

        _getGridConfig: function (gridStore) {
            var context = this.getContext(),
                stateString = 'iteration-tracking-treegrid',
                stateId = context.getScopedStateId(stateString);

            var gridConfig = {
                xtype: 'rallyiterationtrackingtreegrid',
                store: gridStore,
                columnCfgs: this._getGridColumns(),
                summaryColumns: this._getSummaryColumnConfig(),
                enableBulkEdit: context.isFeatureEnabled('BETA_TRACKING_EXPERIENCE'),
                plugins: ['rallycolumnautosizerplugin', 'rallytreegridchildpager'],
                stateId: stateId,
                stateful: true
            };

            if (context.isFeatureEnabled('EXPAND_ALL_TREE_GRID_CHILDREN')) {
                gridConfig.plugins.push({
                    ptype: 'rallytreegridexpandedrowpersistence',
                    enableExpandLoadingMask: !context.isFeatureEnabled('EXPAND_ALL_LOADING_MASK_DISABLE')
                });
            }

            if (context.isFeatureEnabled('S67643_LIMIT_TREEGRID_PAGE_SIZE')) {
                gridConfig.pagingToolbarCfg = {
                    pageSizes: this.getGridPageSizes()
                };
            }

            return gridConfig;
        },

        _getSummaryColumnConfig: function () {
            var taskUnitName = this.getContext().getWorkspace().WorkspaceConfiguration.TaskUnitName,
                planEstimateUnitName = this.getContext().getWorkspace().WorkspaceConfiguration.IterationEstimateUnitName;

            return [
                {
                    field: 'PlanEstimate',
                    type: 'sum',
                    units: planEstimateUnitName
                },
                {
                    field: 'TaskEstimateTotal',
                    type: 'sum',
                    units: taskUnitName
                },
                {
                    field: 'TaskRemainingTotal',
                    type: 'sum',
                    units: taskUnitName
                }
            ];
        },

        _getGridColumns: function (columns) {
            return columns ? _.without(columns, 'FormattedID') : defaultGridColumns;
        },

        _onLoad: function () {
            this._publishContentUpdated();
            this.recordComponentReady();
        },

        _onBoardFilter: function () {
            this.setLoading(true);
        },

        _onBoardFilterComplete: function () {
            this.setLoading(false);
        },

        _hidePrintButton: function(hide, gridboard) {
            var button, menuItem;

            if (this.getContext().isFeatureEnabled('S68103_ITERATION_TRACKING_APP_PRINT') && gridboard) {
                button = _.find(gridboard.plugins, {itemId: 'printExportMenuButton'});

                if (button) {
                    menuItem = _.find(button.menuItems, {text: 'Print...'});

                    if (menuItem) {
                        menuItem.hidden = hide;
                    }
                }
            }
        },

        _onToggle: function (toggleState, gridOrBoard, gridboard) {
            var appEl = this.getEl();

            if (toggleState === 'board') {
                appEl.replaceCls('grid-toggled', 'board-toggled');
                this._hidePrintButton(true, gridboard);
            } else {
                appEl.replaceCls('board-toggled', 'grid-toggled');
                this._hidePrintButton(false, gridboard);
            }
            this._publishContentUpdated();
        },

        _publishContentUpdated: function () {
            this.fireEvent('contentupdated');
        },

        _publishContentUpdatedNoDashboardLayout: function () {
            this.fireEvent('contentupdated', {dashboardLayout: false});
        },

        getGridPageSizes: function() {
            return Ext.isIE ? [10, 25, 50] : [10, 25, 50, 100];
        }
    });
})();


            Rally.launchApp('Rally.apps.iterationtrackingboard.IterationTrackingBoardApp', {
                name:"Iteration Tracking Board",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        @import "RallyVariables.less";

.border-radius(@radius) {
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
  border-radius: @radius;
}

.override-ext-container() {
  > span {
    display: inline !important;
    width: auto !important;

    > div {
      display: block !important;
    }
  }
}

.stat-panel {
  .collapsed-widget,
  .collapsed-widget > div {
    display: none;
  }

  .expanded-widget,
  .expanded-widget > div {
    display: block;
  }

  &.collapsed {
    .collapsed-widget,
    .collapsed-widget > div {
      display: inline-block;
    }

    .expanded-widget,
    .expanded-widget > div {
      display: none;
    }
  }
}

.stats-banner {

  .stat-panel {
    border-top: 1px solid @grey3;
    border-left: 1px solid @grey3;
    border-bottom: 1px solid @grey3;
    height: 110px;
    text-align: center;

    &:first-child {
      border-left: 0;
    }

    &:last-child {
      border-left-width: 2px;
    }

    .stat-title {
      color: @grey9;
      font-family: @proxima-nova-semi-bold;
      font-size: 14px;
      padding-top: 5px;
    }

    .stat-metric {
      color: @grey7;
      font-family: @proxima-nova-light;
      font-size: 18px;
      height: 85px;
      padding-top: 20px;

      .metric-percent {
        display: inline;
        font-size: 12px;
        vertical-align: super;
      }

      .metric-icon {
        color: @grey6;
        font-size: 18px;
        padding-right: 5px;
      }

      .metric-chart {
        position: absolute;
        top: 22px;
        width: 100%;
      }

      .metric-subtext {
        bottom: 7px;
        color: @grey6;
        font-family: @proxima-nova;
        font-size: 11px;
        position: absolute;
        text-transform: lowercase;
        width: 100%;
      }

      .metric-chart-text {
        position: absolute;
        top: 43px;
        width: 100%;

        &.percent-offset {
          left: 3px;
          top: 41px;
        }
      }

      .stat-secondary {
        color: @grey6;
        font-family: @proxima-nova;
        font-size: 11px;
        text-transform: lowercase;
      }

      .stat-carousel {
        display:inline-block;
        font-family: @proxima-nova;
        font-size: 12px;
        margin-top: -20px;

        .rally-carousel-pane {
          .@{prefix}box-inner {
            top: 0px !important;
          }
        }

        .carousel {
          .override-ext-container();

          .carousel-panel {
            .override-ext-container();
          }
        }
      }
    }

    .chart .highcharts-container {
      cursor: pointer;
    }

    .gauge .chart .highcharts-container {
      cursor: default;
    }

    .header {
      display:none;
    }

    &.collapse-expand {
      background-color: @grey1;
      width: 23px;

      .toggle-icon {
        color: @grey4;
        font-size: 18px;
        position: relative;
        right: 1px;
      }

      &:hover {
        cursor: pointer;

        .toggle-icon {
          color: @grey6;
        }
      }
    }
  }

  &.collapsed {
    .stat-panel {
      height: 25px;
      padding-top: 2px;

      .metric-icon {
        color: @grey6;
        font-size: 14px;
        padding-right: 5px;
        vertical-align: middle;
      }

      .stat-title {
        color: @grey9;
        display: inline;
        font-family: @proxima-nova-semi-bold;
        font-size: 12px;
        vertical-align: middle;
      }

      .stat-metric {
        color: @grey6;
        display: inline;
        font-family: @proxima-nova;
        font-size: 14px;
        height: auto;
        padding-top: auto;
        padding-left: 10px;
        vertical-align: middle;

        .stat-metric-secondary {
          font-size: 11px;
        }

        .metric-percent {
          font-size: 10px;
          vertical-align: super;
        }
      }
    }
  }
}

.pie-chart-legend {
  color: #3E576F;
  font-size: 12px;
  padding: 5px;
  border: 1px solid #909090;
  .border-radius(5px);

  .legend-swatch {
    width: 17px;
    height: 12px;
    border: 1px solid #EEE;
    .border-radius(5px);
    float: left;
    margin: 0 3px 0 6px;

    &.defined-sample-swatch {
      background: #E0E0E0; /* light-gray */
    }

    &.in-progress-sample-swatch {
      background: @cyan;
    }

    &.completed-sample-swatch {
      background: @lime;
    }

    &.blocked-sample-swatch {
      background: #EF3F35; /* rally red */
    }
  }
}

.iteration-progress-dialog .carousel .carousel-panel .scroll-button span {
  width: 45px;
  height: 50px;
  line-height: 46px;
  &:hover {
    background-color: @grey2;
    color: @grey7;
  }
}

.iteration-progress-toggle-button-group {
  margin-bottom: 5px;
}

.@{prefix}gecko .stats-banner.collapsed {
  .stat-panel {
    .stat-metric {
      line-height: 20px;
      vertical-align: top;

      .metric-percent {
        line-height: 10px;
      }
    }
  }
}

.@{prefix}gecko.@{prefix}mac .stats-banner.collapsed {
  .stat-panel {
    .stat-metric {
      line-height: 22px;
    }
  }
}
    </style>
    <style type="text/css">
        .iterationtrackingboard {
    overflow-y: hidden;
}

.iterationtrackingboard .header {
    line-height: normal;
    padding: 5px 5px 2px 5px;
}

.iterationtrackingboard .header .add-new {
    float: left;
}

.iterationtrackingboard .header .add-new .new {
    margin-left: 0;
}

.iterationtrackingboard .header .rui-triggerfield {
    margin-bottom: 5px;
}

.iterationtrackingboard .blank-slate-msg .@{prefix}panel-body {
    clear: both;
    padding-top: 20px;
    text-align: center;
}

.iterationtrackingboard .gridboard-filter-control {
    height: 22px;
    margin: 3px 0px 0px 5px;
}

.iterationtrackingboard .rui-leftright {
    margin-bottom: 10px;
}

.settings-no-grid {
    padding: 10px;
}
    </style>
</head>
<body></body>
</html>
